require "file_utils"

module GemframeSample
  module Framework
    module BridgeBindingsGenerator
      extend self

      GENERATED_DIR       = File.expand_path("../../../frontend/src/framework/generated", __DIR__)
      BRIDGE_TS_PATH      = File.join(GENERATED_DIR, "crystal_bridge.ts")

      private class TsTreeNode
        property command : Bridge::CommandSignature?
        getter children : Hash(String, TsTreeNode)

        def initialize
          @command = nil
          @children = {} of String => TsTreeNode
        end
      end

      private struct EventTypeDefinition
        getter payload_type : String
        getter interface_name : String
        getter class_name : String
        getter fields : Array(Bridge::EventField)

        def initialize(
          @payload_type : String,
          @interface_name : String,
          @class_name : String,
          @fields : Array(Bridge::EventField)
        )
        end
      end

      private struct RegisteredTypeDefinition
        getter type_name : String
        getter interface_name : String
        getter class_name : String
        getter fields : Array(Bridge::TypeField)

        def initialize(
          @type_name : String,
          @interface_name : String,
          @class_name : String,
          @fields : Array(Bridge::TypeField)
        )
        end
      end

      private struct TsModelEntry
        getter key : String
        getter interface_name : String
        getter class_name : String
        getter field_names : Array(String)

        def initialize(
          @key : String,
          @interface_name : String,
          @class_name : String,
          @field_names : Array(String)
        )
        end
      end

      def generate!(bridge : Bridge) : Nil
        command_signatures = bridge.command_signatures
        event_signatures = bridge.event_signatures
        type_signatures = bridge.type_signatures
        FileUtils.mkdir_p(GENERATED_DIR)

        bridge_ts = build_bridge_ts(command_signatures, event_signatures, type_signatures)
        write_if_changed(BRIDGE_TS_PATH, bridge_ts)
      end

      private def build_bridge_ts(
        command_signatures : Array(Bridge::CommandSignature),
        event_signatures : Array(Bridge::EventSignature),
        type_signatures : Array(Bridge::TypeSignature)
      ) : String
        event_types = event_type_definitions(event_signatures, type_signatures)
        registered_types = registered_type_definitions(type_signatures, event_types)
        event_types_by_payload = event_types.to_h { |t| {t.payload_type, t} }
        registered_types_by_name = registered_types.to_h { |t| {t.type_name, t} }
        custom_types = collect_custom_types(command_signatures, event_signatures)
        models = model_entries(event_types, registered_types)
        tree = build_ts_tree(command_signatures)

        String.build do |s|
          s << "// Auto-generated by BridgeBindingsGenerator. Do not edit manually.\n\n"
          s << "import { createCommandBridge, invokeCommand } from \"../bridge_runtime.js\";\n\n"
          event_types.each { |definition| write_ts_interface(s, definition) }
          registered_types.each { |definition| write_ts_interface(s, definition) }

          s << "type JsonModelClass<T extends object> = {\n"
          s << "  new(data?: Partial<T>): T & { toJSON(): T };\n"
          s << "  from(data?: Partial<T>): T & { toJSON(): T };\n"
          s << "};\n\n"

          s << "function makeModelClass<T extends object>(fields: readonly (keyof T & string)[]): JsonModelClass<T> {\n"
          s << "  return class {\n"
          s << "    [key: string]: unknown;\n"
          s << "    constructor(data: Partial<T> = {}) {\n"
          s << "      const source = data as Record<string, unknown>;\n"
          s << "      const instance = this as Record<string, unknown>;\n"
          s << "      for (const field of fields) {\n"
          s << "        instance[field] = source[field];\n"
          s << "      }\n"
          s << "    }\n"
          s << "    static from(data: Partial<T> = {}) {\n"
          s << "      return new this(data);\n"
          s << "    }\n"
          s << "    toJSON(): T {\n"
          s << "      const json: Record<string, unknown> = {};\n"
          s << "      for (const field of fields) {\n"
          s << "        json[field] = this[field];\n"
          s << "      }\n"
          s << "      return json as T;\n"
          s << "    }\n"
          s << "  } as unknown as JsonModelClass<T>;\n"
          s << "}\n\n"

          models.each { |model| write_model_class_constant(s, model) }

          unless models.empty?
            s << "\n"
          end

          s << "export interface CrystalEventTopicMap {\n"
          if event_signatures.empty?
            s << "}\n\n"
          else
            event_signatures.each do |signature|
              event_type = event_types_by_payload[signature.payload_type]
              s << "  #{signature.topic.to_json}: #{event_type.interface_name};\n"
            end
            s << "}\n\n"
          end

          s << "export type CrystalKnownEventTopic = keyof CrystalEventTopicMap;\n\n"
          s << "export type CrystalEnvelope<TTopic extends CrystalKnownEventTopic = CrystalKnownEventTopic> = {\n"
          s << "  id: string;\n"
          s << "  version: number;\n"
          s << "  window_id: string;\n"
          s << "  topic: TTopic;\n"
          s << "  timestamp: string;\n"
          s << "  payload: CrystalEventTopicMap[TTopic];\n"
          s << "};\n\n"
          s << "export type CrystalUnknownEnvelope = {\n"
          s << "  topic: string;\n"
          s << "  payload: unknown;\n"
          s << "} & Record<string, unknown>;\n\n"
          s << "export type CrystalBridgeEnvelope = CrystalEnvelope | CrystalUnknownEnvelope;\n\n"

          s << "export interface CrystalEventModelMap {\n"
          if models.empty?
            s << "}\n\n"
          else
            models.each do |model|
              s << "  #{model.key.to_json}: typeof #{model.class_name};\n"
            end
            s << "}\n\n"
          end

          s << "export interface CrystalBridgeTypes {\n"
          if custom_types.empty?
            s << "}\n\n"
          else
            custom_types.each do |custom_type|
              if event_type = event_types_by_payload[custom_type]?
                s << "  #{custom_type.to_json}: #{event_type.interface_name};\n"
              elsif type_definition = registered_types_by_name[custom_type]?
                s << "  #{custom_type.to_json}: #{type_definition.interface_name};\n"
              else
                s << "  #{custom_type.to_json}: unknown;\n"
              end
            end
            s << "}\n\n"
          end

          s << "export type CrystalBridgeModule = "
          write_ts_node(s, tree, 0)
          s << ";\n\n"

          s << "export const CrystalModels: CrystalEventModelMap = {\n"
          models.each { |model| s << "  #{model.key.to_json}: #{model.class_name},\n" }
          s << "};\n\n"

          s << "export const CrystalEventTopics = {\n"
          event_signatures.each do |signature|
            s << "  #{signature.topic.to_json}: #{signature.payload_type.to_json},\n"
          end
          s << "} as const;\n\n"

          s << "const commandHandlers = {\n"
          command_signatures.each { |signature| write_command_handler_entry(s, signature) }
          s << "} as const;\n\n"
          s << "export const CrystalBridge = createCommandBridge<CrystalBridgeModule>(commandHandlers);\n"
          s << "export default CrystalBridge;\n"
        end
      end

      private def event_type_definitions(
        signatures : Array(Bridge::EventSignature),
        type_signatures : Array(Bridge::TypeSignature)
      ) : Array(EventTypeDefinition)
        by_payload = {} of String => Bridge::EventSignature
        signatures.each do |signature|
          by_payload[signature.payload_type] ||= signature
        end

        fields_by_type_name = type_signatures.to_h { |signature| {signature.name, signature.fields} }
        used_identifiers = Set(String).new

        by_payload.keys.sort.map do |payload_type|
          signature = by_payload[payload_type]
          base_identifier = ts_type_identifier(payload_type)
          interface_name = unique_identifier(base_identifier, used_identifiers)
          class_name = unique_identifier("#{interface_name}Model", used_identifiers)
          fields = if signature.fields.empty?
                     map_type_fields_to_event_fields(fields_by_type_name[payload_type]? || [] of Bridge::TypeField)
                   else
                     signature.fields
                   end

          EventTypeDefinition.new(
            payload_type,
            interface_name,
            class_name,
            fields
          )
        end
      end

      private def map_type_fields_to_event_fields(type_fields : Array(Bridge::TypeField)) : Array(Bridge::EventField)
        type_fields.map do |field|
          Bridge::EventField.new(field.name, field.type, field.required)
        end
      end

      private def registered_type_definitions(
        signatures : Array(Bridge::TypeSignature),
        event_types : Array(EventTypeDefinition)
      ) : Array(RegisteredTypeDefinition)
        event_payload_types = event_types.map(&.payload_type).to_set
        used_identifiers = Set(String).new
        event_types.each do |event_type|
          used_identifiers << event_type.interface_name
          used_identifiers << event_type.class_name
        end

        signatures
          .reject { |signature| event_payload_types.includes?(signature.name) }
          .sort_by(&.name)
          .map do |signature|
            base_identifier = ts_type_identifier(signature.name)
            interface_name = unique_identifier(base_identifier, used_identifiers)
            class_name = unique_identifier("#{interface_name}Model", used_identifiers)

            RegisteredTypeDefinition.new(
              signature.name,
              interface_name,
              class_name,
              signature.fields
            )
          end
      end

      private def model_entries(
        event_types : Array(EventTypeDefinition),
        registered_types : Array(RegisteredTypeDefinition)
      ) : Array(TsModelEntry)
        entries = [] of TsModelEntry

        event_types.each do |event_type|
          entries << TsModelEntry.new(
            event_type.payload_type,
            event_type.interface_name,
            event_type.class_name,
            event_type.fields.map(&.name)
          )
        end

        registered_types.each do |type_definition|
          entries << TsModelEntry.new(
            type_definition.type_name,
            type_definition.interface_name,
            type_definition.class_name,
            type_definition.fields.map(&.name)
          )
        end

        entries
      end

      private def write_ts_interface(io : IO, definition : EventTypeDefinition) : Nil
        write_ts_interface(io, definition.interface_name, definition.fields)
      end

      private def write_ts_interface(io : IO, definition : RegisteredTypeDefinition) : Nil
        write_ts_interface(io, definition.interface_name, definition.fields)
      end

      private def write_ts_interface(
        io : IO,
        interface_name : String,
        fields : Array(Bridge::EventField)
      ) : Nil
        io << "export interface #{interface_name} {\n"
        fields.each do |field|
          write_ts_field(io, field.name, field.type, field.required)
        end
        io << "}\n\n"
      end

      private def write_ts_interface(
        io : IO,
        interface_name : String,
        fields : Array(Bridge::TypeField)
      ) : Nil
        io << "export interface #{interface_name} {\n"
        fields.each do |field|
          write_ts_field(io, field.name, field.type, field.required)
        end
        io << "}\n\n"
      end

      private def write_ts_field(io : IO, name : String, type : String, required : Bool) : Nil
        field_name = ts_property_name(name)
        field_type = ts_type_for(type)
        io << "  #{field_name}"
        io << "?" unless required
        io << ": #{field_type};\n"
      end

      private def write_model_class_constant(io : IO, model : TsModelEntry) : Nil
        field_names = model.field_names.map(&.to_json).join(", ")
        io << "export const #{model.class_name} = makeModelClass<#{model.interface_name}>([#{field_names}]);\n"
      end

      private def unique_identifier(base : String, used : Set(String)) : String
        candidate = base
        suffix = 2

        while used.includes?(candidate)
          candidate = "#{base}#{suffix}"
          suffix += 1
        end

        used << candidate
        candidate
      end

      private def ts_type_identifier(type : String) : String
        sanitized = type.gsub(/[^a-zA-Z0-9_$]/, "_")
        sanitized = "_#{sanitized}" if sanitized.empty?
        sanitized = "_#{sanitized}" if sanitized[0].ascii_number?
        sanitized
      end

      private def write_command_handler_entry(io : IO, signature : Bridge::CommandSignature) : Nil
        js_params = signature.params.map do |param|
          param_name = sanitize_js_identifier(param.name)
          param_type = ts_type_for(param.type)
          param.required ? "#{param_name}: #{param_type}" : "#{param_name}?: #{param_type}"
        end.join(", ")
        args_call = signature.params.map { |param| sanitize_js_identifier(param.name) }.join(", ")
        return_type = ts_type_for(signature.returns)

        io << "  #{signature.command.to_json}: async (#{js_params}) => "
        if args_call.empty?
          io << "invokeCommand(\"#{signature.command}\") as Promise<#{return_type}>"
        else
          io << "invokeCommand(\"#{signature.command}\", #{args_call}) as Promise<#{return_type}>"
        end
        io << ",\n"
      end

      private def build_ts_tree(signatures : Array(Bridge::CommandSignature)) : TsTreeNode
        root = TsTreeNode.new

        signatures.each do |signature|
          parts = signature.command.split('.')
          node = root
          parts.each do |part|
            child = node.children[part]?
            unless child
              child = TsTreeNode.new
              node.children[part] = child
            end
            node = child
          end
          node.command = signature
        end

        root
      end

      private def write_ts_node(io : IO, node : TsTreeNode, indent : Int32) : Nil
        if node.command && node.children.empty?
          io << ts_function_type(node.command.not_nil!)
          return
        end

        io << "{\n"
        keys = node.children.keys.sort
        keys.each_with_index do |key, index|
          child = node.children[key]
          io << ("  " * (indent + 1))
          io << "#{ts_property_name(key)}: "
          write_ts_node(io, child, indent + 1)
          io << ";"
          io << "\n" if index < keys.size
        end
        io << ("  " * indent)
        io << "}"
      end

      private def ts_function_type(signature : Bridge::CommandSignature) : String
        params = signature.params.map do |param|
          param_name = sanitize_js_identifier(param.name)
          param_type = ts_type_for(param.type)
          param.required ? "#{param_name}: #{param_type}" : "#{param_name}?: #{param_type}"
        end.join(", ")

        "(#{params}) => Promise<#{ts_type_for(signature.returns)}>"
      end

      private def ts_property_name(name : String) : String
        if name =~ /\A[$A-Za-z_][$A-Za-z0-9_]*\z/
          name
        else
          name.to_json
        end
      end

      private def collect_custom_types(
        command_signatures : Array(Bridge::CommandSignature),
        event_signatures : Array(Bridge::EventSignature)
      ) : Array(String)
        set = Set(String).new

        command_signatures.each do |signature|
          collect_custom_types_from_type(signature.returns, set)
          signature.params.each do |param|
            collect_custom_types_from_type(param.type, set)
          end
        end

        event_signatures.each do |signature|
          collect_custom_types_from_type(signature.payload_type, set)
          signature.fields.each do |field|
            collect_custom_types_from_type(field.type, set)
          end
        end

        set.to_a.sort
      end

      private def collect_custom_types_from_type(type : String, set : Set(String)) : Nil
        normalized = normalize_type(type)
        return if normalized.empty?

        union_parts = split_union_types(normalized)
        if union_parts.size > 1
          union_parts.each { |part| collect_custom_types_from_type(part, set) }
          return
        end

        if (match = normalized.match(/\AArray\((.+)\)\z/))
          collect_custom_types_from_type(match[1], set)
          return
        end

        if (match = normalized.match(/\AHash\((.+),\s*(.+)\)\z/))
          collect_custom_types_from_type(match[1], set)
          collect_custom_types_from_type(match[2], set)
          return
        end

        return if Framework::TypeMetadata.primitive_type?(normalized)

        set << normalized
      end

      private def ts_type_for(type : String) : String
        normalized = normalize_type(type)
        return "unknown" if normalized.empty?

        union_parts = split_union_types(normalized)
        if union_parts.size > 1
          return union_parts.map { |part| ts_type_for(part) }.uniq.join(" | ")
        end

        if (match = normalized.match(/\AArray\((.+)\)\z/))
          return "#{ts_type_for(match[1])}[]"
        end

        if (match = normalized.match(/\AHash\((.+),\s*(.+)\)\z/))
          value_type = ts_type_for(match[2])
          return "Record<string, #{value_type}>"
        end

        primitive_ts = Framework::TypeMetadata.ts_primitive_type(normalized)
        if primitive_ts
          primitive_ts
        else
          "CrystalBridgeTypes[#{normalized.to_json}]"
        end
      end

      private def split_union_types(type : String) : Array(String)
        type.split('|').map(&.strip).reject(&.empty?)
      end

      private def normalize_type(type : String) : String
        normalized = type.strip
        while normalized.starts_with?('(') && normalized.ends_with?(')')
          normalized = normalized[1..-2].strip
        end
        normalized
      end

      private def sanitize_js_identifier(name : String) : String
        sanitized = name.gsub(/[^a-zA-Z0-9_$]/, "_")
        sanitized = "_#{sanitized}" if sanitized.empty?
        sanitized = "_#{sanitized}" if sanitized[0].ascii_number?
        sanitized
      end

      private def write_if_changed(path : String, content : String) : Nil
        existing = File.exists?(path) ? File.read(path) : nil
        return if existing == content

        File.write(path, content)
        TerminalLog.bridge(
          "generator",
          "write",
          JSON::Any.new({"path" => JSON::Any.new(path)})
        )
      end
    end
  end
end
