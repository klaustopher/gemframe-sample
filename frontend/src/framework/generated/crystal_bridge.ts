// Auto-generated by BridgeBindingsGenerator. Do not edit manually.

import { createCommandBridge, invokeCommand } from "../bridge_runtime.js";

export interface JobCompletedEvent {
  job_id: string;
  percent: number;
  message: string;
  done: boolean;
}

export interface JobErrorEvent {
  job_id: string;
  message: string;
  done: boolean;
}

export interface JobProgressEvent {
  job_id: string;
  percent: number;
  delay_seconds: number;
  message: string;
  done: boolean;
}

export interface JobStartedEvent {
  job_id: string;
  source: string;
  message: string;
}

export interface JobStartResult {
  job_id: string;
  status: string;
}

export interface RuntimeInfo {
  crystal_version: string;
  frontend_url: string;
}

type JsonModelClass<T extends object> = {
  new(data?: Partial<T>): T & { toJSON(): T };
  from(data?: Partial<T>): T & { toJSON(): T };
};

function makeModelClass<T extends object>(fields: readonly (keyof T & string)[]): JsonModelClass<T> {
  return class {
    [key: string]: unknown;
    constructor(data: Partial<T> = {}) {
      const source = data as Record<string, unknown>;
      const instance = this as Record<string, unknown>;
      for (const field of fields) {
        instance[field] = source[field];
      }
    }
    static from(data: Partial<T> = {}) {
      return new this(data);
    }
    toJSON(): T {
      const json: Record<string, unknown> = {};
      for (const field of fields) {
        json[field] = this[field];
      }
      return json as T;
    }
  } as unknown as JsonModelClass<T>;
}

export const JobCompletedEventModel = makeModelClass<JobCompletedEvent>(["job_id", "percent", "message", "done"]);
export const JobErrorEventModel = makeModelClass<JobErrorEvent>(["job_id", "message", "done"]);
export const JobProgressEventModel = makeModelClass<JobProgressEvent>(["job_id", "percent", "delay_seconds", "message", "done"]);
export const JobStartedEventModel = makeModelClass<JobStartedEvent>(["job_id", "source", "message"]);
export const JobStartResultModel = makeModelClass<JobStartResult>(["job_id", "status"]);
export const RuntimeInfoModel = makeModelClass<RuntimeInfo>(["crystal_version", "frontend_url"]);

export interface CrystalEventTopicMap {
  "job.complete": JobCompletedEvent;
  "job.error": JobErrorEvent;
  "job.progress": JobProgressEvent;
  "job.started": JobStartedEvent;
}

export type CrystalKnownEventTopic = keyof CrystalEventTopicMap;

export type CrystalEnvelope<TTopic extends CrystalKnownEventTopic = CrystalKnownEventTopic> = {
  id: string;
  version: number;
  window_id: string;
  topic: TTopic;
  timestamp: string;
  payload: CrystalEventTopicMap[TTopic];
};

export type CrystalUnknownEnvelope = {
  topic: string;
  payload: unknown;
} & Record<string, unknown>;

export type CrystalBridgeEnvelope = CrystalEnvelope | CrystalUnknownEnvelope;

export interface CrystalEventModelMap {
  "JobCompletedEvent": typeof JobCompletedEventModel;
  "JobErrorEvent": typeof JobErrorEventModel;
  "JobProgressEvent": typeof JobProgressEventModel;
  "JobStartedEvent": typeof JobStartedEventModel;
  "JobStartResult": typeof JobStartResultModel;
  "RuntimeInfo": typeof RuntimeInfoModel;
}

export interface CrystalBridgeTypes {
  "JobCompletedEvent": JobCompletedEvent;
  "JobErrorEvent": JobErrorEvent;
  "JobProgressEvent": JobProgressEvent;
  "JobStartResult": JobStartResult;
  "JobStartedEvent": JobStartedEvent;
  "RuntimeInfo": RuntimeInfo;
}

export type CrystalBridgeModule = {
  greeter: {
    greet: (name: string, time_of_day_iso8601: string) => Promise<string>;
  };
  hello: (name: string) => Promise<string>;
  jobs: {
    start_demo: (source?: string) => Promise<CrystalBridgeTypes["JobStartResult"]>;
  };
  math: {
    add: (left: number, right: number) => Promise<number>;
    divide: (left: number, right: number) => Promise<number>;
    multiply: (left: number, right: number) => Promise<number>;
    subtract: (left: number, right: number) => Promise<number>;
  };
  runtime: {
    info: () => Promise<CrystalBridgeTypes["RuntimeInfo"]>;
  };
};

export const CrystalModels: CrystalEventModelMap = {
  "JobCompletedEvent": JobCompletedEventModel,
  "JobErrorEvent": JobErrorEventModel,
  "JobProgressEvent": JobProgressEventModel,
  "JobStartedEvent": JobStartedEventModel,
  "JobStartResult": JobStartResultModel,
  "RuntimeInfo": RuntimeInfoModel,
};

export const CrystalEventTopics = {
  "job.complete": "JobCompletedEvent",
  "job.error": "JobErrorEvent",
  "job.progress": "JobProgressEvent",
  "job.started": "JobStartedEvent",
} as const;

const commandHandlers = {
  "greeter.greet": async (name: string, time_of_day_iso8601: string) => invokeCommand("greeter.greet", name, time_of_day_iso8601) as Promise<string>,
  "hello": async (name: string) => invokeCommand("hello", name) as Promise<string>,
  "jobs.start_demo": async (source?: string) => invokeCommand("jobs.start_demo", source) as Promise<CrystalBridgeTypes["JobStartResult"]>,
  "math.add": async (left: number, right: number) => invokeCommand("math.add", left, right) as Promise<number>,
  "math.divide": async (left: number, right: number) => invokeCommand("math.divide", left, right) as Promise<number>,
  "math.multiply": async (left: number, right: number) => invokeCommand("math.multiply", left, right) as Promise<number>,
  "math.subtract": async (left: number, right: number) => invokeCommand("math.subtract", left, right) as Promise<number>,
  "runtime.info": async () => invokeCommand("runtime.info") as Promise<CrystalBridgeTypes["RuntimeInfo"]>,
} as const;

export const CrystalBridge = createCommandBridge<CrystalBridgeModule>(commandHandlers);
export default CrystalBridge;
